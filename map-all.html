<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Test D3</title>
    <script type="text/javascript" src="d3/d3.js"></script>

    <style type="text/css">
      .brushed {
            fill: #ff3399;
            stroke: #8e1b54;
            opacity: 1.0;
        }
      .non_brushed {
        display: none;
      }
      .button {
          border: 1px solid;
          padding: 8px 16px;
          cursor: pointer;
          background-color: #2196F3;
          margin: 20px;
      }
	  </style>

  </head>

  <body>
    <script type="text/javascript">

      //Width and height
      var w = 1300;
      var h = 800;
      var margin = {top: 20, right: 20, bottom: 60, left: 80};
      var graphHeight = 200;
      var circles, allData;
      var days = 4017;
      var barWidth = w/days+0.2;
      var parseDate = d3.timeParse("%m/%d/%Y");

      var boroColor = ["#FF4136", "green", "orange", "steelblue", "pink"];

      //Define map projection
      var projection = d3.geoMercator()
                   .translate([w/2, h/2])
                   .scale(50000)
                   .center([-73.90, 40.80]);

      //Define path generator
      var path = d3.geoPath()
               .projection(projection);

      //Create SVG element
      var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);

      var xScale = d3.scaleTime()
                      .domain([new Date("January 1, 2006"), new Date("December 31, 2017")])
                      .range([0,w]);

      var yScale;

      var brush = d3.brushX()
        .extent([[0, 0], [w, graphHeight]])
        .on("start brush", brushed);

      var g = svg.append("g")
          .attr("transform", "translate(" + margin.left + ",0)")
          .call(brush);

      //Load in GeoJSON data
      d3.json("boroughs.json", function(json) {
        //Bind data and create one path per GeoJSON feature
        console.log(json)
        svg.selectAll("path")
           .data(json.features)
           .enter()
           .append("path")
           .attr("d", path)
           .style("fill", function(d, i) {
              return boroColor[i];
           });

           d3.csv("all_murder.csv", function(rawData) {
              allData = rawData;
              var data = getData(rawData);

              var max = d3.max(data, function(d) {
                return d.murders;
              });

              yScale = d3.scaleLinear()
                           .domain([0, max])
                           .rangeRound([graphHeight, 5]);

             circles = svg.selectAll("circle")
               .data(rawData)
               .enter()
               .append("circle")
               .attr("cx", function(d) {
                 return projection([d.Longitude, d.Latitude])[0];
               })
               .attr("cy", function(d) {
                 return projection([d.Longitude, d.Latitude])[1];
               })
               .attr("r", 2.5)
               .attr("class", "brushed")
               .attr("data-time", function(d) {
                 return d.RPT_DT;
               });

             g.append("g")
              .attr("class", "x-axis")
              .attr("transform", "translate(0,"+graphHeight+")")
              .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y")));

             svg.append("text")
               .attr("transform", "translate("+w/2+","+(graphHeight+20)+")")
               .attr("dy", "0.71em")
               .text("Day");

             g.append("g")
              .attr("class", "y-axis")
              .call(d3.axisLeft().scale(yScale));

             svg.append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 30)
              .attr("x", -20)
              .attr("dy", "0.71em")
              .attr("text-anchor", "end")
              .text("# of murders committed");

             g.selectAll(".bar")
              .data(data)
              .enter()
              .append("rect")
                 .attr("x", function(d, i) {
      			   		 return xScale(parseDate(d.date));
        			   })
        			   .attr("y", function(d) {
        			   		return yScale(d.murders);
        			   })
        			   .attr("width", barWidth)
        			   .attr("height", function(d) {
        			   		return graphHeight - yScale(d.murders);
        			   })
                .attr("class", "bar")
                .attr("fill", function(d) {
                 return "steelblue";
                });

                svg.append("text")
                  .attr("transform", "translate(20,"+(graphHeight+60)+")")
                  .attr("class", "button")
                  .on("click", function() {
                    animate();
                  })
                  .style("fill", "#2196F3")
                  .text("Animate");
           });
      });

      function brushed() {
        var extent = d3.event.selection.map(xScale.invert, xScale);

        var firstTime = extent[0].getTime();
        var lastTime = extent[1].getTime();

        circles.filter(function() {
          var date = parseDate(this.getAttribute('data-time'));
          var time = date.getTime()

          if (firstTime > time || lastTime < time) {
            this.classList.add('non_brushed');
            this.classList.remove('brushed');
          } else {
            this.classList.add('brushed');
            this.classList.remove('non_brushed');
          }
        });
      }

      function animate() {
        var step  = 0;
        var animation = setInterval(function(){
          g.call(brush.move, [0+step, 250+step]);
          if ((step+250) > w) {
            clearInterval(animation);
          }
          step+=5;
        }, 30);

        //brush.extent(20)
      }

      function brushended() {
        d3.select(this).transition()
            .duration(brush.empty() ? 0 : 750)
            .call(brush.extent(defaultExtent))
            .call(brush.event);
      }


      function getData(rawData) {
        var sortedData = [];
        for (line in rawData) {
          if ("RPT_DT" in rawData[line]) {
            if (!(rawData[line].RPT_DT in sortedData)) {
              sortedData[rawData[line].RPT_DT] = 0;
            }
            sortedData[rawData[line].RPT_DT]++;
          }
        }

        var finalArray = [];
        for (var i in sortedData) {
          var object = {
            date: i,
            murders: sortedData[i]
          }
          finalArray.push(object);
        }

        return finalArray;
      }
    </script>

  </body>
</html>
